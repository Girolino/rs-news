---
title: Middleware
url: 'https://trpc.io/docs/server/middlewares'
category: server
section: server
fetched: true
last_updated: 2025-10-22T14:17:58.145Z
fetchedAt: '2025-10-22T14:29:24.700Z'
---
Version: 11.x

On this page

You are able to add middleware(s) to a procedure with the `t.procedure.use()` method. The middleware(s) will wrap the invocation of the procedure and must pass through its return value.

## Authorization[​](#authorization "Direct link to Authorization")

In the example below, any call to a `adminProcedure` will ensure that the user is an "admin" before executing.

ts

`   import { TRPCError, initTRPC } from '@trpc/server';  interface Context {    user?: {      id: string;      isAdmin: boolean;      // [..]    };  }  const t = initTRPC.context<Context>().create();  export const publicProcedure = t.procedure;  export const router = t.router;  export const adminProcedure = publicProcedure.use(async (opts) => {    const { ctx } = opts;    if (!ctx.user?.isAdmin) {      throw new TRPCError({ code: 'UNAUTHORIZED' });    }    return opts.next({      ctx: {        user: ctx.user,      },    });  });   `

Copy

ts

`   import { TRPCError, initTRPC } from '@trpc/server';  interface Context {    user?: {      id: string;      isAdmin: boolean;      // [..]    };  }  const t = initTRPC.context<Context>().create();  export const publicProcedure = t.procedure;  export const router = t.router;  export const adminProcedure = publicProcedure.use(async (opts) => {    const { ctx } = opts;    if (!ctx.user?.isAdmin) {      throw new TRPCError({ code: 'UNAUTHORIZED' });    }    return opts.next({      ctx: {        user: ctx.user,      },    });  });   `

Copy

ts

`   import { adminProcedure, publicProcedure, router } from './trpc';  const adminRouter = router({    secretPlace: adminProcedure.query(() => 'a key'),  });  export const appRouter = router({    foo: publicProcedure.query(() => 'bar'),    admin: adminRouter,  });   `

Copy

ts

`   import { adminProcedure, publicProcedure, router } from './trpc';  const adminRouter = router({    secretPlace: adminProcedure.query(() => 'a key'),  });  export const appRouter = router({    foo: publicProcedure.query(() => 'bar'),    admin: adminRouter,  });   `

Copy

tip

See [Error Handling](/docs/server/error-handling) to learn more about the `TRPCError` thrown in the above example.

## Logging[​](#logging "Direct link to Logging")

In the example below timings for queries are logged automatically.

ts

`   export const loggedProcedure = publicProcedure.use(async (opts) => {    const start = Date.now();    const result = await opts.next();    const durationMs = Date.now() - start;    const meta = { path: opts.path, type: opts.type, durationMs };    result.ok      ? console.log('OK request timing:', meta)      : console.error('Non-OK request timing', meta);    return result;  });   `

Copy

ts

`   export const loggedProcedure = publicProcedure.use(async (opts) => {    const start = Date.now();    const result = await opts.next();    const durationMs = Date.now() - start;    const meta = { path: opts.path, type: opts.type, durationMs };    result.ok      ? console.log('OK request timing:', meta)      : console.error('Non-OK request timing', meta);    return result;  });   `

Copy

ts

`   import { loggedProcedure, router } from './trpc';  export const appRouter = router({    foo: loggedProcedure.query(() => 'bar'),    abc: loggedProcedure.query(() => 'def'),  });   `

Copy

ts

`   import { loggedProcedure, router } from './trpc';  export const appRouter = router({    foo: loggedProcedure.query(() => 'bar'),    abc: loggedProcedure.query(() => 'def'),  });   `

Copy

## Context Extension[​](#context-extension "Direct link to Context Extension")

"Context Extension" enables middlewares to dynamically add and override keys on a base procedure's context in a typesafe manner.

Below we have an example of a middleware that changes properties of a context, the changes are then available to all chained consumers, such as other middlewares and procedures:

ts

``   type Context = {    // user is nullable    user?: {      id: string;    };  };  const protectedProcedure = publicProcedure.use(async function isAuthed(opts) {    const { ctx } = opts;    // `ctx.user` is nullable    if (!ctx.user) {                (property) user: {     id: string; } | undefined      throw new TRPCError({ code: 'UNAUTHORIZED' });    }    return opts.next({      ctx: {        // ✅ user value is known to be non-null now        user: ctx.user,           (property) user: {     id: string; }      },    });  });  protectedProcedure.query((opts) => {    const { ctx } = opts;    return ctx.user;             const ctx: {     user: {         id: string;     }; }  });   ``

Copy

ts

``   type Context = {    // user is nullable    user?: {      id: string;    };  };  const protectedProcedure = publicProcedure.use(async function isAuthed(opts) {    const { ctx } = opts;    // `ctx.user` is nullable    if (!ctx.user) {                (property) user: {     id: string; } | undefined      throw new TRPCError({ code: 'UNAUTHORIZED' });    }    return opts.next({      ctx: {        // ✅ user value is known to be non-null now        user: ctx.user,           (property) user: {     id: string; }      },    });  });  protectedProcedure.query((opts) => {    const { ctx } = opts;    return ctx.user;             const ctx: {     user: {         id: string;     }; }  });   ``

Copy

## Using `.concat()` to create reusable middlewares and plugins[​](#concat "Direct link to concat")

tip

*   Creating middlewares using `t.middleware` has the limitation that the `Context` type is tied to the `Context` type of the tRPC instance.
*   Creating middlewares with `experimental_standaloneMiddleware()` has the limitation that you cannot define input parsers and similar tied to your module.

tRPC has an API called `.concat()` which allows you to independently define a partial procedure that can be used with any tRPC instance that matches the context and metadata of the plugin.

This helper primarily targets creating plugins and libraries with tRPC.

ts

``   // ------------------------------------------------  // 🧩🧩🧩 a library creating a reusable plugin 🧩🧩🧩  // @filename: myPlugin.ts  import { initTRPC, TRPCError } from '@trpc/server';  export function createMyPlugin() {    // When creating a plugin for tRPC, you use the same API as creating any other tRPC-app    // this is the plugin's root `t`-object    const t = initTRPC      .context<{        // the procedure using the plugin will need to extend this context      }>()      .meta<{        // the base `initTRPC`-object of the application using this needs to extend this meta      }>()      .create();    return {      // you can also add `.input()` if you want your plugin to do input validation      pluginProc: t.procedure.use((opts) => {        return opts.next({          ctx: {            fromPlugin: 'hello from myPlugin' as const,          },        });      }),    };  }  // ------------------------------------  // 🚀🚀🚀 the app using the plugin 🚀🚀🚀  // @filename: app.ts  import { createMyPlugin } from './myPlugin';  import { initTRPC, TRPCError } from '@trpc/server';  // the app's root `t`-object  const t = initTRPC    .context<{      // ...    }>()    .create();  export const publicProcedure = t.procedure;  export const router = t.router;  // initialize the plugin (a real-world example would likely take options here)  const plugin = createMyPlugin();  // create a base procedure using the plugin  const procedureWithPlugin = publicProcedure    .concat(      plugin.pluginProc,    )    .use(opts => {      const { ctx } = opts;                const ctx: {     fromPlugin: "hello from myPlugin"; }      return opts.next()    })  export const appRouter = router({    hello: procedureWithPlugin.query(opts => {      return opts.ctx.fromPlugin;    })  })   ``

Copy

ts

``   // ------------------------------------------------  // 🧩🧩🧩 a library creating a reusable plugin 🧩🧩🧩  // @filename: myPlugin.ts  import { initTRPC, TRPCError } from '@trpc/server';  export function createMyPlugin() {    // When creating a plugin for tRPC, you use the same API as creating any other tRPC-app    // this is the plugin's root `t`-object    const t = initTRPC      .context<{        // the procedure using the plugin will need to extend this context      }>()      .meta<{        // the base `initTRPC`-object of the application using this needs to extend this meta      }>()      .create();    return {      // you can also add `.input()` if you want your plugin to do input validation      pluginProc: t.procedure.use((opts) => {        return opts.next({          ctx: {            fromPlugin: 'hello from myPlugin' as const,          },        });      }),    };  }  // ------------------------------------  // 🚀🚀🚀 the app using the plugin 🚀🚀🚀  // @filename: app.ts  import { createMyPlugin } from './myPlugin';  import { initTRPC, TRPCError } from '@trpc/server';  // the app's root `t`-object  const t = initTRPC    .context<{      // ...    }>()    .create();  export const publicProcedure = t.procedure;  export const router = t.router;  // initialize the plugin (a real-world example would likely take options here)  const plugin = createMyPlugin();  // create a base procedure using the plugin  const procedureWithPlugin = publicProcedure    .concat(      plugin.pluginProc,    )    .use(opts => {      const { ctx } = opts;                const ctx: {     fromPlugin: "hello from myPlugin"; }      return opts.next()    })  export const appRouter = router({    hello: procedureWithPlugin.query(opts => {      return opts.ctx.fromPlugin;    })  })   ``

Copy

## Extending middlewares[​](#extending-middlewares "Direct link to Extending middlewares")

info

We have prefixed this as `unstable_` as it's a new API, but you're safe to use it! [Read more](/docs/faq#unstable).

We have a powerful feature called `.pipe()` which allows you to extend middlewares in a typesafe manner.

Below we have an example of a middleware that extends a base middleware(foo). Like the context extension example above, piping middlewares will change properties of the context, and procedures will receive the new context value.

ts

`   const fooMiddleware = t.middleware((opts) => {    return opts.next({      ctx: {        foo: 'foo' as const,      },    });  });  const barMiddleware = fooMiddleware.unstable_pipe((opts) => {    const { ctx } = opts;    ctx.foo;          (property) foo: "foo"    return opts.next({      ctx: {        bar: 'bar' as const,      },    });  });  const barProcedure = publicProcedure.use(barMiddleware);  barProcedure.query((opts) => {    const { ctx } = opts;    return ctx.bar;             const ctx: {     foo: "foo";     bar: "bar"; }  });   `

Copy

ts

`   const fooMiddleware = t.middleware((opts) => {    return opts.next({      ctx: {        foo: 'foo' as const,      },    });  });  const barMiddleware = fooMiddleware.unstable_pipe((opts) => {    const { ctx } = opts;    ctx.foo;          (property) foo: "foo"    return opts.next({      ctx: {        bar: 'bar' as const,      },    });  });  const barProcedure = publicProcedure.use(barMiddleware);  barProcedure.query((opts) => {    const { ctx } = opts;    return ctx.bar;             const ctx: {     foo: "foo";     bar: "bar"; }  });   `

Copy

Beware that the order in which you pipe your middlewares matter and that the context must overlap. An example of a forbidden pipe is shown below. Here, the `fooMiddleware` overrides the `ctx.a` while `barMiddleware` still expects the root context from the initialization in `initTRPC` - so piping `fooMiddleware` with `barMiddleware` would not work, while piping `barMiddleware` with `fooMiddleware` does work.

ts

``   import { initTRPC } from '@trpc/server';  const t = initTRPC    .context<{      a: {        b: 'a';      };    }>()    .create();  const fooMiddleware = t.middleware((opts) => {    const { ctx } = opts;    ctx.a; // 👈 fooMiddleware expects `ctx.a` to be an object         (property) a: {     b: "a"; }    return opts.next({      ctx: {        a: 'a' as const, // 👈 `ctx.a` is no longer an object      },    });  });  const barMiddleware = t.middleware((opts) => {    const { ctx } = opts;    ctx.a; // 👈 barMiddleware expects `ctx.a` to be an object         (property) a: {     b: "a"; }    return opts.next({      ctx: {        foo: 'foo' as const,      },    });  });  // ❌ `ctx.a` does not overlap from `fooMiddleware` to `barMiddleware`  fooMiddleware.unstable_pipe(barMiddleware);  Argument of type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to parameter of type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { a: "a"; }, { foo: "foo"; }, unknown> | MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.   Type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to type 'MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.             Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.               Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { a: { b: "a"; }; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { a: "a"; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.a' are incompatible between these types.                       Type '{ b: "a"; }' is not assignable to type '"a"'.2345Argument of type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to parameter of type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { a: "a"; }, { foo: "foo"; }, unknown> | MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.   Type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to type 'MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.             Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.               Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { a: { b: "a"; }; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { a: "a"; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.a' are incompatible between these types.                       Type '{ b: "a"; }' is not assignable to type '"a"'.  // ✅ `ctx.a` overlaps from `barMiddleware` and `fooMiddleware`  barMiddleware.unstable_pipe(fooMiddleware);   ``

Copy

ts

``   import { initTRPC } from '@trpc/server';  const t = initTRPC    .context<{      a: {        b: 'a';      };    }>()    .create();  const fooMiddleware = t.middleware((opts) => {    const { ctx } = opts;    ctx.a; // 👈 fooMiddleware expects `ctx.a` to be an object         (property) a: {     b: "a"; }    return opts.next({      ctx: {        a: 'a' as const, // 👈 `ctx.a` is no longer an object      },    });  });  const barMiddleware = t.middleware((opts) => {    const { ctx } = opts;    ctx.a; // 👈 barMiddleware expects `ctx.a` to be an object         (property) a: {     b: "a"; }    return opts.next({      ctx: {        foo: 'foo' as const,      },    });  });  // ❌ `ctx.a` does not overlap from `fooMiddleware` to `barMiddleware`  fooMiddleware.unstable_pipe(barMiddleware);  Argument of type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to parameter of type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { a: "a"; }, { foo: "foo"; }, unknown> | MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.   Type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to type 'MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.             Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.               Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { a: { b: "a"; }; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { a: "a"; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.a' are incompatible between these types.                       Type '{ b: "a"; }' is not assignable to type '"a"'.2345Argument of type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to parameter of type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { a: "a"; }, { foo: "foo"; }, unknown> | MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.   Type 'MiddlewareBuilder<{ a: { b: "a"; }; }, object, { foo: "foo"; }, unknown>' is not assignable to type 'MiddlewareBuilder<{ a: "a"; }, object, { foo: "foo"; }, unknown>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, $ContextOverridesOut, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, $ContextOverridesOut, unknown>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: "a"; foo: "foo"; }, object, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.             Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown> | MiddlewareBuilder<{ a: { b: "a"; }; foo: "foo"; }, object, any, unknown>'.               Type 'MiddlewareFunction<{ a: "a"; }, object, { foo: "foo"; }, any, unknown>' is not assignable to type 'MiddlewareFunction<{ a: { b: "a"; }; }, object, { foo: "foo"; }, any, unknown>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { a: { b: "a"; }; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { a: "a"; foo: "foo"; }; type: "query" | "mutation" | "subscription"; path: string; input: unknown; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.a' are incompatible between these types.                       Type '{ b: "a"; }' is not assignable to type '"a"'.  // ✅ `ctx.a` overlaps from `barMiddleware` and `fooMiddleware`  barMiddleware.unstable_pipe(fooMiddleware);   ``

Copy

## Experimental: standalone middlewares[​](#experimental-standalone-middlewares "Direct link to Experimental: standalone middlewares")

info

This has been deprecated in favor of `.concat()`

tRPC has an experimental API called `experimental_standaloneMiddleware` which allows you to independently define a middleware that can be used with any tRPC instance. Creating middlewares using `t.middleware` has the limitation that the `Context` type is tied to the `Context` type of the tRPC instance. This means that you cannot use the same middleware with multiple tRPC instances that have different `Context` types.

Using `experimental_standaloneMiddleware` you can create a middleware that explicitly defines its requirements, i.e. the Context, Input and Meta types:

ts

``  import {    experimental_standaloneMiddleware,    initTRPC,    TRPCError,  } from '@trpc/server';  import * as z from 'zod';  const projectAccessMiddleware = experimental_standaloneMiddleware<{    ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined    input: { projectId: string }; // defaults to 'unknown' if not defined    // 'meta', not defined here, defaults to 'object | undefined'  }>().create((opts) => {    if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {      throw new TRPCError({        code: 'FORBIDDEN',        message: 'Not allowed',      });    }    return opts.next();  });  const t1 = initTRPC    .context<{      allowedProjects: string[];    }>()    .create();  // ✅ `ctx.allowedProjects` satisfies "string[]" and `input.projectId` satisfies "string"  const accessControlledProcedure = t1.procedure    .input(z.object({ projectId: z.string() }))    .use(projectAccessMiddleware);  // ❌ `ctx.allowedProjects` satisfies "string[]" but `input.projectId` does not satisfy "string"  const accessControlledProcedure2 = t1.procedure    .input(z.object({ projectId: z.number() }))    .use(projectAccessMiddleware);  Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }> | MiddlewareFunction<{ allowedProjects: string[]; }, object, object, object, { projectId: number; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: number; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'input.projectId' are incompatible between these types.                       Type 'string' is not assignable to type 'number'.2345Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }> | MiddlewareFunction<{ allowedProjects: string[]; }, object, object, object, { projectId: number; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: number; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'input.projectId' are incompatible between these types.                       Type 'string' is not assignable to type 'number'.  // ❌ `ctx.allowedProjects` does not satisfy "string[]" even though `input.projectId` satisfies "string"  const t2 = initTRPC    .context<{      allowedProjects: number[];    }>()    .create();  const accessControlledProcedure3 = t2.procedure    .input(z.object({ projectId: z.string() }))    .use(projectAccessMiddleware);  Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }> | MiddlewareFunction<{ allowedProjects: number[]; }, object, object, object, { projectId: string; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: number[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: number[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.allowedProjects' are incompatible between these types.                       Type 'string[]' is not assignable to type 'number[]'.                         Type 'string' is not assignable to type 'number'.2345Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }> | MiddlewareFunction<{ allowedProjects: number[]; }, object, object, object, { projectId: string; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: number[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: number[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.allowedProjects' are incompatible between these types.                       Type 'string[]' is not assignable to type 'number[]'.                         Type 'string' is not assignable to type 'number'.``

Copy

ts

``  import {    experimental_standaloneMiddleware,    initTRPC,    TRPCError,  } from '@trpc/server';  import * as z from 'zod';  const projectAccessMiddleware = experimental_standaloneMiddleware<{    ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined    input: { projectId: string }; // defaults to 'unknown' if not defined    // 'meta', not defined here, defaults to 'object | undefined'  }>().create((opts) => {    if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {      throw new TRPCError({        code: 'FORBIDDEN',        message: 'Not allowed',      });    }    return opts.next();  });  const t1 = initTRPC    .context<{      allowedProjects: string[];    }>()    .create();  // ✅ `ctx.allowedProjects` satisfies "string[]" and `input.projectId` satisfies "string"  const accessControlledProcedure = t1.procedure    .input(z.object({ projectId: z.string() }))    .use(projectAccessMiddleware);  // ❌ `ctx.allowedProjects` satisfies "string[]" but `input.projectId` does not satisfy "string"  const accessControlledProcedure2 = t1.procedure    .input(z.object({ projectId: z.number() }))    .use(projectAccessMiddleware);  Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }> | MiddlewareFunction<{ allowedProjects: string[]; }, object, object, object, { projectId: number; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: number; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'input.projectId' are incompatible between these types.                       Type 'string' is not assignable to type 'number'.2345Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }> | MiddlewareFunction<{ allowedProjects: string[]; }, object, object, object, { projectId: number; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: number; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: number; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: number; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'input.projectId' are incompatible between these types.                       Type 'string' is not assignable to type 'number'.  // ❌ `ctx.allowedProjects` does not satisfy "string[]" even though `input.projectId` satisfies "string"  const t2 = initTRPC    .context<{      allowedProjects: number[];    }>()    .create();  const accessControlledProcedure3 = t2.procedure    .input(z.object({ projectId: z.string() }))    .use(projectAccessMiddleware);  Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }> | MiddlewareFunction<{ allowedProjects: number[]; }, object, object, object, { projectId: string; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: number[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: number[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.allowedProjects' are incompatible between these types.                       Type 'string[]' is not assignable to type 'number[]'.                         Type 'string' is not assignable to type 'number'.2345Argument of type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to parameter of type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }> | MiddlewareFunction<{ allowedProjects: number[]; }, object, object, object, { projectId: string; }>'.   Type 'MiddlewareBuilder<{ allowedProjects: string[]; }, object, object, { projectId: string; }>' is not assignable to type 'MiddlewareBuilder<{ allowedProjects: number[]; }, object, object, { projectId: string; }>'.     Types of property 'unstable_pipe' are incompatible.       Type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: string[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>' is not assignable to type '<$ContextOverridesOut>(fn: MiddlewareFunction<{ allowedProjects: number[]; }, object, object, $ContextOverridesOut, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, $ContextOverridesOut, { ...; }>) => MiddlewareBuilder<...>'.         Types of parameters 'fn' and 'fn' are incompatible.           Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: number[]; }, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.             Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }> | MiddlewareBuilder<{ allowedProjects: string[]; }, object, any, { projectId: string; }>'.               Type 'MiddlewareFunction<{ allowedProjects: number[]; }, object, object, any, { projectId: string; }>' is not assignable to type 'MiddlewareFunction<{ allowedProjects: string[]; }, object, object, any, { projectId: string; }>'.                 Types of parameters 'opts' and 'opts' are incompatible.                   Type '{ ctx: { allowedProjects: string[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }' is not assignable to type '{ ctx: { allowedProjects: number[]; }; type: "query" | "mutation" | "subscription"; path: string; input: { projectId: string; }; getRawInput: GetRawInputFn; meta: object | undefined; signal: AbortSignal | undefined; next: { ...; }; }'.                     The types of 'ctx.allowedProjects' are incompatible between these types.                       Type 'string[]' is not assignable to type 'number[]'.                         Type 'string' is not assignable to type 'number'.``

Copy

Here is an example with multiple standalone middlewares:

ts

``   import { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';  import * as z from 'zod';  const t = initTRPC.create();  const schemaA = z.object({ valueA: z.string() });  const schemaB = z.object({ valueB: z.string() });  const valueAUppercaserMiddleware = experimental_standaloneMiddleware<{    input: z.infer<typeof schemaA>;  }>().create((opts) => {    return opts.next({      ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },    });  });  const valueBUppercaserMiddleware = experimental_standaloneMiddleware<{    input: z.infer<typeof schemaB>;  }>().create((opts) => {    return opts.next({      ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },    });  });  const combinedInputThatSatisfiesBothMiddlewares = z.object({    valueA: z.string(),    valueB: z.string(),    extraProp: z.string(),  });  t.procedure    .input(combinedInputThatSatisfiesBothMiddlewares)    .use(valueAUppercaserMiddleware)    .use(valueBUppercaserMiddleware)    .query(      ({        input: { valueA, valueB, extraProp },        ctx: { valueAUppercase, valueBUppercase },      }) =>        `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,    );   ``

Copy

ts

``   import { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';  import * as z from 'zod';  const t = initTRPC.create();  const schemaA = z.object({ valueA: z.string() });  const schemaB = z.object({ valueB: z.string() });  const valueAUppercaserMiddleware = experimental_standaloneMiddleware<{    input: z.infer<typeof schemaA>;  }>().create((opts) => {    return opts.next({      ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },    });  });  const valueBUppercaserMiddleware = experimental_standaloneMiddleware<{    input: z.infer<typeof schemaB>;  }>().create((opts) => {    return opts.next({      ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },    });  });  const combinedInputThatSatisfiesBothMiddlewares = z.object({    valueA: z.string(),    valueB: z.string(),    extraProp: z.string(),  });  t.procedure    .input(combinedInputThatSatisfiesBothMiddlewares)    .use(valueAUppercaserMiddleware)    .use(valueBUppercaserMiddleware)    .query(      ({        input: { valueA, valueB, extraProp },        ctx: { valueAUppercase, valueBUppercase },      }) =>        `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,    );   ``

Copy

*   [Authorization](#authorization)
*   [Logging](#logging)
*   [Context Extension](#context-extension)
*   [Using `.concat()` to create reusable middlewares and plugins](#concat)
*   [Extending middlewares](#extending-middlewares)
*   [Experimental: standalone middlewares](#experimental-standalone-middlewares)
